import React from 'react';
import Alert from '../../components/Alert';
import Image from '../../components/Image';
import Link from '../../components/Link';
import { CopyBlock, hybrid } from 'react-code-blocks';

import * as code from './code';

const Lesson03 = () => (
  <div className="container lesson-03">
    <div className="row">
      <div className="col">
        <h2>1. Компоненты-классы</h2>
        <p>
          Если необходимо добавить динамику, компоненты создаются как классы,
          потому что компоненты-функции (до хуков) ограничены возможностью
          создания разметки по полученным пропсам.
        </p>
        <Image filename="class-component.jpg" />
        <ul>
          <li>
            Обычный ES6 класс, поэтому применяются все правила: конструктор,
            методы, контекст (this).
          </li>
          <li>
            Обязательно расширяет базовый класс <code>React.Component</code>.
          </li>
          <li>
            Действует как функция, которая получает <code>props</code>, но также
            реализует приватное внутреннее состояние.
          </li>
          <li>
            Необходимо объявить обязательный метод <code>render()</code>,
            который вызывается по умолчанию и возвращает JSX-разметку.
          </li>
          <li>
            Каждый раз при использовании компонента-класса, React будет
            создавать экземпляр компонента (класса), поэтому доступ к пропсам
            происходит через
            <code>this.props</code>.
          </li>
          <li>
            Можно определить кастомные методы класса и использовать их в любом
            месте, в том числе внутри JSX, вызывать или передавать детям как
            пропсы.
          </li>
          <li>
            Когда изменяется состояние или пропcы компонента, происходит его
            ре-рендер.
          </li>
        </ul>
        <CopyBlock text={code.code1} theme={hybrid} language="jsx" />
      </div>
    </div>

    <div className="row">
      <div className="col">
        <h2>2. События</h2>
        <p>
          Для нативного события браузера в React создается объект-обертка
          <code>SyntheticEvent Object</code> с идентичным интерфейсом. Это
          необходимо чтобы предоставить кросс-бразуерность и оптимизировать
          производительность.
        </p>
        <CopyBlock text={code.code2} theme={hybrid} language="jsx" />
        <ul>
          <li>
            Добавление обработчика событий с{' '}
            <code>EventTarget.addEventListener()</code> почти не используется,
            за редким исключением.
          </li>
          <li>
            Пропсы событий не исключение и именуются с помощью camelCase.
            Например
            <code>onClick</code>, <code>onChange</code>, <code>onSubmit</code>,{' '}
            <code>onMouseEnter</code>.
          </li>
          <li>
            В проп события передается ссылка на callback-функцию, которая будет
            вызвана при наступлении события.
          </li>
          <li>
            Обработчики событий получают экземпляр{' '}
            <code>SyntheticEvent Object</code>.
          </li>
        </ul>
        <p>
          В React реализовано глобальное делегирование событий. Слушатели не
          добавляются к DOM-элементам напрямую. React использует один обработчик
          событий на корне документа, который отвечает за прослушивание всех
          событий и при необходимости вызывает соответствующий обработчик.
        </p>
        <Alert>
          <p>
            Именно поэтому объект <code>SyntheticEvent</code> всего один (на все
            приложение) и доступен только в синхронном коде. Сразу после вызова
            callback-функции он будет использован повторно и все свойства будут
            аннулированы.
          </p>
        </Alert>

        <h3>2.1. Счетчик</h3>
        <p>
          Создадим компонент-счетчик с возможностью увеличения и уменьшения
          значения.
        </p>
        <CopyBlock text={code.code3} theme={hybrid} language="jsx" />

        <h3>2.2. Анонимные колбеки</h3>
        <p>
          Инлайн колбеки считаются антипаттерном. Каждый раз когда компонент
          ре-рендерится, будет создана новая callback-функция. В многих случаях
          это нормально. Но, если callback передается как проп нижележащим
          компонентам в дереве, они будут отрендерены заново, так как придут
          новые пропы ссылочного типа (функция).
        </p>
        <CopyBlock text={code.code4} theme={hybrid} language="jsx" />

        <h3>2.3. Кастомные методы</h3>
        <p>
          Чаще всего обработчики событий объявляются как методы класса, после
          чего jsx-атрибуту передается ссылка на метод.
        </p>
        <CopyBlock text={code.code5} theme={hybrid} language="jsx" />

        <h3>2.4. Привязка контекста</h3>
        <p>
          Нужно всегда помнить о значении <code>this</code> в методах
          использующихся как callback-функции. В JavaScript, контекст в методах
          класса не привязывается по умолчанию. Если забыть привязать контекст,
          и передать метод как callback-функцию обработчику события, во время
          вызова функции, <code>this</code> будет неопределен (
          <code>undefined</code>).
        </p>

        <h3>2.4.1. Привязка при передаче колбека</h3>
        <p>
          Избегайте привязки контекста в методе <code>render()</code>. Всякий
          раз, когда компонент ре-рендерится,{' '}
          <code>Function.prototype.bind()</code> возвращает новую функцию и
          передает ее вниз по дереву компонентов, что приводит к повторному
          рендеру дочерних компонентов. При достаточном количестве, это
          оказывает существенное влияние на производительность.
        </p>
        <CopyBlock text={code.code6} theme={hybrid} language="jsx" />

        <h3>2.4.2. Привязка в конструкторе</h3>
        <p>
          Еще один способ привязать контекст - сделать это в конструкторе
          класса. Если callback-функций много, можете себе представить,
          насколько большой может получиться конструктор.
        </p>
        <ul>
          <li>
            Конструктор выполняется один раз, поэтому <code>bind</code>{' '}
            вызовется один раз
          </li>
          <li>
            Методы класса записываеются в свойство prototype
            функции-конструктора
          </li>
        </ul>
        <CopyBlock text={code.code7} theme={hybrid} language="jsx" />

        <h3>2.4.3. Публичные свойства класса</h3>
        <p>
          Несмотря на то, что это рекомендуемый способ привязки контекста,
          синтаксис публичных полей класса еще не стандартизирован. Но они уже
          настолько широко используются, что даже если будут синтаксические
          изменения, транспайлер Babel все сделает за нас.
        </p>
        <p>
          При объявлении публичных полей класса, они записываются не в свойство
          <code>prototype</code> функции-конструктора, а в объект экземпляра.
        </p>
        <CopyBlock text={code.code8} theme={hybrid} language="jsx" />

        <h3>2.5. Дополнительные материалы</h3>
        <ul>
          <li>
            <Link
              link="https://ru.reactjs.org/docs/events.html"
              text="Документация SyntheticEvent"
            />
          </li>
          <li>
            <Link
              link="https://codeburst.io/pointer-events-with-react-the-why-how-what-617a5b51dbb2"
              text="Pointer events with React"
            />
          </li>
        </ul>
      </div>
    </div>

    <div className="row">
      <div className="col">
        <h2>3. Внутреннее состояние компонента</h2>
        <p>
          Объект-состояния <code>state</code> это свойство класса которое не
          должно изменяться разработчиком напрямую.
        </p>
        <ul>
          <li>
            Данные в <code>state</code> контролируют то, что отображается в
            интерфейсе.
          </li>
          <li>
            Данные, хранящиеся в состоянии, должны быть информацией, которая
            будет обновляться методами компонента.
          </li>
          <li>
            Не нужно дублировать данные из <code>props</code> в состоянии.
          </li>
          <li>
            Каждый раз, когда изменяется состояние компонента (или пропсы),
            вызывается метод <code>render()</code>.
          </li>
        </ul>
        <p>
          В состоянии хранят минимально необходимый набор данных, на основе
          которых можно вычислить все необходимое для отрисовки интерфейса. Это
          делается вызовом селекторов (функций которые составляют данные для
          интерфейса на основе состояния) в методе <code>render()</code>. Так мы
          получаем вычисляемые данные.
        </p>
        <Image filename="reactivity.jpg" />
        <ul>
          <li>Интерфейс зависит от состояния компонента.</li>
          <li>
            Состояние может измениться как реакция на действия пользователя.
          </li>
          <li>
            При изменении состояния, данные передаются вниз по дереву
            компонентов.
          </li>
          <li>
            Компоненты возвращают обновленную разметку и изменяется интерфейс.
          </li>
        </ul>
        <p>
          Состояние принадлежит компоненту и изменяется только его методами.
          Изменение состояния компонента никогда не повлияет на его родителя,
          соседей или любой другой компонент в приложении - только на его
          дочерние элементы. При такой модели, данные в приложении передаются
          только одним, жестко ограниченным образом. Это называется
          однонаправленный поток данных.
        </p>
        <Image filename="data-flow.data-flow.jpg" />
        <p>
          Состояние объявляется в конструкторе, так как это первое, что
          происходит, когда создается экземпляр класса.
        </p>
        <CopyBlock text={code.code9} theme={hybrid} language="jsx" />

        <h3>3.1. Начальное состояние от props</h3>
        <p>
          Иногда начальное состояние зависит от переданных пропсов, например
          начальное значение нашего счетчика. В этом случае, необходимо явно
          объявить параметр
          <code>props</code> в конструкторе и передать его в вызов{' '}
          <code>super(props)</code>. Тогда в конструкторе будет доступно{' '}
          <code>this.props</code>.
        </p>
        <CopyBlock text={code.code10} theme={hybrid} language="jsx" />

        <p>
          Так как под капотом используется Babel, можно пропустить утомительное
          объявление конструктора и указать состояние как публичное свойство
          класса, все остальное транспайлер сделает за нас.
        </p>
        <CopyBlock text={code.code11} theme={hybrid} language="jsx" />

        <h3>3.2. Изменение состояния компонента</h3>
        <p>
          Для обновления состояния используется встроенный метод{' '}
          <code>setState()</code>.
        </p>
        <CopyBlock text={code.code12} theme={hybrid} language="jsx" />

        <ul>
          <li>
            Первым, обязательным аргументом, передается объект с полями
            указывающими какую часть состояния необходимо изменить.
          </li>
          <li>
            Вторым, необязательным аргументом, можно передать callback-функцию
            которая выполнится после изменения состояния.
          </li>
        </ul>
        <Alert type="error">
          <p>
            Нельзя изменять состояние напрямую по ссылке. Будьте очень
            внимательны, особенно при работе со ссылочными типами (массив,
            объект).
          </p>
        </Alert>
        <CopyBlock text={code.code13} theme={hybrid} language="jsx" />

        <p>
          Этот подход используется когда новое состояние не рассчитывается на
          основе предыдущего. То есть когда в состояние записывается что-то
          новое, перезаписывая уже существующее. Сделаем компонент с
          переключателем, методы которого будут перезаписывать значение{' '}
          <code>isOpen</code> в состоянии.
        </p>
        <CopyBlock text={code.code14} theme={hybrid} language="jsx" />

        <h3>3.3. Как обновляется состояние</h3>
        <p>
          При вызове <code>setState()</code> не нужно передавать все свойства
          хранящиеся в состоянии. Достаточно указать только ту часть (срез)
          состояния, которую мы хотим изменить в данной операции. React затем
          берет текущее состояние и объект, который был передан в{' '}
          <code>setState()</code>, объединяя их следующим образом.
        </p>
        <CopyBlock text={code.code15} theme={hybrid} language="jsx" />

        <h3>3.4. Асинхронность обновления состояния</h3>
        <p>
          Метод <code>setState()</code> регистрирует асинхронную операцию
          обновления состояния, которая ставится в очередь обновлений. React
          изменяет состояние не для каждого вызова <code>setState()</code>, а
          может объединять несколько вызовов в одно обновление для повышения
          производительности. Из-за этого доступ к <code>this.state</code>, в
          синхронном коде, после вызова этого метода вернет значение до
          обновления.
        </p>
        <p>
          Представьте, что при изменении состояния, вы полагаетесь на текущее
          значение состояния при вычислении следующего. Используем цикл{' '}
          <code>for</code> для создания (регистрации) нескольких обновлений.
        </p>
        <CopyBlock text={code.code16} theme={hybrid} language="jsx" />

        <p>
          Значение свойства <code>this.state.value</code> запоминается во время
          создания объекта передаваемого в <code>setState()</code>, а не во
          время обновления состояния. То есть, если в момент создания объекта,{' '}
          <code>this.state.value</code> содержало <code>0</code>, в функцию
          <code>setState()</code> передается объект{' '}
          <code>{'{value: 0 + 1}'}</code>.
        </p>
        <p>
          В результате выполнения цикла получаем очередь из 3-х объектов
          <code>
            {'{value: 0 + 1}'}, {'{value: 0 + 1}'}, {'{value: 0 + 1}'}
          </code>{' '}
          и оригинальное состояние на момент обновления{' '}
          <code>{'{value: 0 + 1}'}</code>. После всех обновлений получаем
          состояние
          <code>{'{value: 0 + 1}'}</code>.
        </p>
        <p>
          Поэтому нельзя полагаться на текущее состояние при вычислении
          следующего, зависящего от предыдущего на момент обновления. Это может
          привести к ошибкам. Поэтому существует второй способ обновить
          состояние.
        </p>

        <h3>3.5. setState с функцией</h3>
        <p>
          Этот подход используется, когда новое значение вычисляется на основе
          предыдущего состояния. Метод <code>setState()</code>, первым
          аргументом, может принимать не объект, а функцию, которая должна
          возвращать объект которым мы хотим обновить состояние.
        </p>
        <CopyBlock text={code.code17} theme={hybrid} language="jsx" />

        <p>
          Актуальное состояние и пропы, на момент асинхронного исполнения
          функции переданной в <code>setState()</code>, будут переданы в нее
          аргументами <code>state</code> и <code>props</code>. Таким образом,
          можно быть уверенными в корректном значении предыдущего состояния при
          создании следующего.
        </p>
        <CopyBlock text={code.code18} theme={hybrid} language="jsx" />

        <p>
          Каждый раз, во время вызова функции переданной в{' '}
          <code>setState()</code>, в параметр
          <code>prevState</code> будет передана ссылка на актуальное состояние в
          момент обновления. Получим объекты обновлений{' '}
          <code>{'{value: 0 + 1}'}</code>, <code>{'{value: 1 + 1}'}</code>,{' '}
          <code>{'{value: 2 + 1}'}</code>, и, в результате,{' '}
          <code>this.state.value</code> будет содержать <code>3</code>.
        </p>
        <p>
          Теперь можем заменить функционал открыть/закрыть в компоненте{' '}
          <code>
            <span class="token tag">
              <span class="token tag">
                <span class="token punctuation">&lt;</span>Toggle
              </span>
              <span class="token punctuation">&gt;</span>
            </span>
          </code>
          .
        </p>
        <CopyBlock text={code.code19} theme={hybrid} language="jsx" />

        <p>А счетчик будет выглядеть так.</p>
        <CopyBlock text={code.code20} theme={hybrid} language="jsx" />

        <h3>3.6. Подъем состояния (state hoisting)</h3>
        <p>
          Так как React использует однонаправленный поток данных сверху вниз,
          для того, чтобы изменить состояние родителя при событии в ребенке,
          используется следующий паттерн с callback-функцией.
        </p>
        <Image filename="state-hoisting.gif" />
        <ul>
          <li>В родителе есть состояние и метод который его изменяет.</li>
          <li>
            Ребенку, в виде пропа, пробрасывается метод родителя изменяющий
            состояние родителя.
          </li>
          <li>В ребенке происходит вызов переданного ему метода.</li>
          <li>При вызове этого метода изменяется состояние родителя.</li>
          <li>Происходит ре-рендер поддерева компонентов родителя.</li>
        </ul>
        <p>Рассмотрим простой, но наглядный пример.</p>
        <CopyBlock text={code.code21} theme={hybrid} language="jsx" />

        <p>
          При клике кнопки, состояние <code>App</code> обновляется с помощью
          callback-функции, контекст которой привязан к <code>App</code>. Этот
          паттерн устанавливает четкую границу между "умными" и "глупыми"
          компонентами.
        </p>
        <p>Паттерн подъема состояния может иметь любую вложенность.</p>
        <Image filename="deep-state-hoisting.gif" />
      </div>
    </div>

    <div className="row">
      <div className="col">
        <h2>4. Типы внутренних данных компонента</h2>
        <ul>
          <li>
            <code>static data</code> - статические свойства и методы к которым
            необходимо получать доступ без экземпляра.
          </li>
          <li>
            <code>this.state.data</code> - динамические данные изменяющиеся
            методами компонента, состояние.
          </li>
          <li>
            <code>this.data</code> - данные которые будут разные для каждого
            экземпляра.
          </li>
          <li>
            <code>const DATA</code> - константы, данные которые не изменяются и
            одинаковы для всех экземпляров.
          </li>
        </ul>
      </div>
    </div>
  </div>
);

export default Lesson03;
