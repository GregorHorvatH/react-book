{"version":3,"sources":["pages/Lesson-08/index.js","pages/Lesson-08/code.js","components/Link/index.js","components/Image/index.js"],"names":["Lesson08","className","Image","filename","text","theme","hybrid","language","Link","link","href","target","rel","src","process","alt","loading"],"mappings":"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","file":"static/js/lesson-08.27891a67.chunk.js","sourcesContent":["import React from 'react';\nimport { CopyBlock, hybrid } from 'react-code-blocks';\nimport Image from '../../components/Image';\nimport Link from '../../components/Link';\n\nimport * as code from './code';\n\nconst Lesson08 = () => (\n  <div className=\"container lesson-08\">\n    <div className=\"row\">\n      <div className=\"col\">\n        <h2>1. Code splitting</h2>\n        <p>\n          Когда приложение становится достаточно большим, монолитный бандл со\n          всем исходным кодом загружается, парсится и исполняется, долго\n          (секунды, особенно на мобильных). Но если пользователь заходит на\n          страницу логина, не имеет смысла загружать остальную часть приложения.\n        </p>\n        <p>\n          Секция приложения может импортировать большое количество компонентов,\n          которые не нужны при первой загрузке. Необходимо разбивать бандл на\n          отдельные файлы (chunks, чанки) и загружать их динамически, только\n          когда это необходимо.\n        </p>\n        <Image filename=\"split-bundle.png\" />\n\n        <h3>1.1. Динамический импорт в ESM</h3>\n        <CopyBlock text={code.code1} theme={hybrid} language=\"jsx\" />\n\n        <p>\n          Create React App поддерживает разделение кода и позволяет динамически\n          импортировать части приложения используя <code>import()</code>.\n        </p>\n        <ul>\n          <li>\n            <Link\n              link=\"https://developers.google.com/web/updates/2017/11/dynamic-import\"\n              text=\"Dynamic import()\"\n            />\n          </li>\n          <li>\n            <Link\n              link=\"https://github.com/tc39/proposal-dynamic-import#import\"\n              text=\"proposal-dynamic-import\"\n            />\n          </li>\n        </ul>\n      </div>\n    </div>\n\n    <div className=\"row\">\n      <div className=\"col\">\n        <h2>2. Route-based и Component-based splitting</h2>\n        <p>\n          Первый подход состоит в разбиении приложения на отдельные маршруты и\n          загрузке каждого маршрута асинхронно. Этого вполне достаточно для\n          большинства приложений, переходим на новый раут - загружается\n          необходимый код для его обслуживания.\n        </p>\n        <p>\n          Но есть еще один вариант. Раут это просто компонент. Поэтому можно\n          разделять код на уровне компонентов, а не маршрутов. Какая в этом\n          выгода?\n        </p>\n        <p>\n          В действительно большом приложении - огромная. Интерфейсы могут быть\n          очень громоздкими, и в тех местах, где модальные окна, вкладки,\n          скрытые формы и т. п., не нужны до определенного действия\n          пользователя, разделение кода помогает ускорить рендер страницы.\n        </p>\n        <Image filename=\"route-vs-component-split.png\" />\n\n        <p>\n          Это не значит что необходимо использовать один или другой подход,\n          используйте оба. Делите и маршруты, и части страницы, это все просто\n          компоненты. Как, что и где разделять это целиком ваше решение,\n          зависящее от сложившейся ситуации.\n        </p>\n        <p>\n          Чрезмерный сплитинг, кстати, тоже не лучшая идея. HTTP-запрос за\n          файлом может быть дольше чем добавленный вес к первой загрузке.\n        </p>\n\n        <h3>2.1. asyncComponent HOC</h3>\n        <ul>\n          <li>\n            Функция <code>asyncComponent</code> принимает объект настроек из\n            двух свойств: <code>loader</code> - функция, которая при вызове\n            будет динамически импортировать компонент,\n            <code>loading</code> - компонент который будем показывать пока идет\n            HTTP-запрос.\n          </li>\n          <li>\n            В <code>componentDidMount</code> мы просто вызываем функцию{' '}\n            <code>loader</code>, и сохраняем динамически загруженный компонент в\n            состояние.\n          </li>\n          <li>\n            После чего делаем рендер по условию, где рендерим загруженный\n            компонент, если он уже загрузился. В противном случае рендерим\n            компонент <code>Loading</code>.\n          </li>\n        </ul>\n        <CopyBlock text={code.code2} theme={hybrid} language=\"jsx\" />\n\n        <p>Теперь используем эту функцию для динамической загрузки страниц.</p>\n        <CopyBlock text={code.code3} theme={hybrid} language=\"jsx\" />\n\n        <p>\n          Важно понимать, что здесь не происходит импорта компонента. Мы\n          передаем функцию которая будет использована для динамического импорта,\n          когда будет создан компонент <code>AsyncHome</code>.\n        </p>\n        <p>\n          Может показаться странным, что мы передаем функцию. Почему бы просто\n          не передать строку <code>'./pages/Home'</code>, а затем выполнить\n          динамический импорт внутри\n          <code>asyncComponent</code>?\n        </p>\n        <p>\n          Это связано с тем, что мы хотим явно указать компонент, который мы\n          динамически импортируем. Основываясь на этом, Webpack разбивает наше\n          приложение. Он смотрит на эти импорты и генерирует необходимые чанки\n          (куски, chunks).\n        </p>\n        <p>\n          После создания <code>AsyncHome</code> мы можем использовать его в\n          маршрутах. При совпадении маршрута, React Router создаст экземпляр\n          компонента <code>AsyncHome</code>, который, в свою очередь,\n          динамически импортирует компонент <code>Home</code> и отрендерит его.\n        </p>\n        <CopyBlock text={code.code4} theme={hybrid} language=\"jsx\" />\n        <Image filename=\"split.png\" />\n\n        <p>\n          Каждый из файлов <code>.chunk.js</code> - это вызовы{' '}\n          <code>import()</code>, асинхронно загружаемые компоненты.\n        </p>\n\n        <h3>2.2. Имена чанков</h3>\n        <p>Если необходимо дать чанкам вменяемые имена, делается это так:</p>\n        <CopyBlock text={code.code5} theme={hybrid} language=\"jsx\" />\n        <Link\n          link=\"https://github.com/webpack/webpack/tree/master/examples/code-splitting-specify-chunk-name\"\n          text=\"ode-splitting-specify-chunk-name\"\n        />\n      </div>\n    </div>\n\n    <div className=\"row\">\n      <div className=\"col\">\n        <h2>3. React Loadable</h2>\n        <p>\n          Что произойдет, если запрос на импорт нового компонента займет слишком\n          много времени или HTTP-запрос не удастся. Или, возможно, необходимо\n          предварительно загрузить определенные компоненты. Например,\n          пользователь находится странице логина, и необходимо предварительно\n          загрузить домашнюю страницу.\n        </p>\n        <p>\n          <code>React Loadable</code> - небольшая библиотека, которая упрощает\n          разделение компонентно-ориентированного кода.\n        </p>\n        <p>\n          <code>Loadable</code> - компонент высшего порядка, который позволяет\n          легко разделить код на уровне компонентов.\n        </p>\n        <Link\n          link=\"https://github.com/jamiebuilds/react-loadable\"\n          text=\"Репозиторий react-loadable\"\n        />\n        <p>Добавим пакет в проект.</p>\n        <CopyBlock text={code.code6} theme={hybrid} language=\"jsx\" />\n\n        <p>\n          Достаточно заменить <code>asyncComponent</code> на{' '}\n          <code>Loadable</code> и все продолжит работать как и раньше.\n        </p>\n        <p>\n          Одно но, можно улучшить компонент <code>Loading</code>, потому что{' '}\n          <code>react-loadable</code>\n          прокидывает ему несколько очень полезных свойств.\n        </p>\n        <CopyBlock text={code.code7} theme={hybrid} language=\"jsx\" />\n      </div>\n    </div>\n\n    <div className=\"row\">\n      <div className=\"col\">\n        <h2>4. React.lazy версии 16.6+</h2>\n        <p>\n          Официальный API который позволяет рендерить динамически загружаемый\n          компонент. Заменит <code>react-loadable</code>.\n        </p>\n        <CopyBlock text={code.code8} theme={hybrid} language=\"jsx\" />\n\n        <p>\n          Принимает функцию-згарузчик которая возвращает результат динамического\n          импорта - промис, значение которого будет дефолтный экспорт модуля,\n          реакт компонент.\n        </p>\n        <CopyBlock text={code.code9} theme={hybrid} language=\"jsx\" />\n\n        <p>\n          Если во время ренедера <code>MyComponent</code>, компонент{' '}\n          <code>AsyncComponent</code> еще не загружен, необходимо показать\n          фолбек. Для этого используется компонент\n          <code>Suspense</code>. Проп <code>fallback</code> принимает любой\n          React-элемент. <code>Susupense</code> можно поместить в любом месте\n          над асинхронным компонентом, даже оборачивая целую группу.\n        </p>\n        <Link\n          link=\"https://reactjs.org/docs/code-splitting.html#reactlazy\"\n          text=\"Документация React.lazy\"\n        />\n      </div>\n    </div>\n\n    <div className=\"row\">\n      <div className=\"col\">\n        <h2>5. Дополнительные материалы</h2>\n        <ul>\n          <li>\n            <Link\n              link=\"https://alligator.io/react/react-loadable/\"\n              text=\"Code Splitting in React Using React Loadable\"\n            />\n          </li>\n          <li>\n            <Link\n              link=\"https://youtu.be/bb6RCrDaxhw\"\n              text=\"Neehar Venugopal - A Beginner's Guide to Code Splitting Your React\n              App - React Conf 2017\"\n            />\n          </li>\n          <li>\n            <Link\n              link=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/javascript-startup-optimization/\"\n              text=\"JavaScript Start-up Optimization\"\n            />\n          </li>\n        </ul>\n      </div>\n    </div>\n  </div>\n);\n\nexport default Lesson08;\n","export const code1 = `// Статический импорт, всегда в начале файла\nimport moduleA from './path/to/module-a';\n\n/*\n *  Динамический импорт, где угодно\n * Путь к модулю должен быть полный, без выражений\n */\nconst loadModuleB = () => import('./path/to/module-b');\n\n/*\n * Можно использовать в любом месте, к примеру при событии\n * import() возвращает обещание\n */\nloadModuleB().then(module => {\n  // Объект модуля с полем default - дефолтный экспорт\n  console.log(module);\n});`;\n\nexport const code2 = `// asyncComponent.js\n\nconst asyncComponent = ({ loader, loading: Loading }) => {\n  return class AsyncComponent extends Component {\n    state = {\n      component: null,\n    };\n\n    async componentDidMount() {\n      const { default: component } = await loader();\n\n      this.setState({ component });\n    }\n\n    render() {\n      const { component: LoadedComponent } = this.state;\n\n      return LoadedComponent ? (\n        <LoadedComponent {...this.props} />\n      ) : (\n        <Loading />\n      );\n    }\n  };\n};`;\n\nexport const code3 = `const AsyncHome = asyncComponent({\n  loader: () => import('./pages/Home'),\n  loading: Loader,\n});`;\n\nexport const code4 = `<Route path=\"/\" exact component={AsyncHome} />`;\n\nexport const code5 = `const AsyncHome = asyncComponent({\n  loader: () => import('./pages/Home' /* webpackChunkName: \"home-page\" */),\n  loading: Loader,\n});`;\n\nexport const code6 = `npm install react-loadable`;\n\nexport const code7 = `const Loading = ({ error, timedOut, pastDelay, retry }) => {\n  if (error) {\n    return (\n      <div>\n        Error! <button onClick={retry}>Retry</button>\n      </div>\n    );\n  }\n\n  if (timedOut) {\n    return (\n      <div>\n        Taking a long time... <button onClick={retry}>Retry</button>\n      </div>\n    );\n  }\n\n  if (pastDelay) {\n    return <div>Loading...</div>;\n  }\n\n  return null;\n};`;\n\nexport const code8 = `React.lazy(loader);`;\n\nexport const code9 = `import React, { lazy, Suspense } from 'react';\n\nconst AsyncComponent = lazy(() => import('./AsyncComponent'));\n\nconst MyComponent = () => (\n  <Suspense fallback={<div>Loading...</div>}>\n    <AsyncComponent />\n  </Suspense>\n);`;\n","import React from 'react';\n\nconst Link = ({ link, text }) => (\n  <a href={link} target=\"_blank\" rel=\"noopener noreferrer\">\n    {text}\n  </a>\n);\n\nexport default Link;\n","import React from 'react';\n\nconst Image = ({ filename }) => (\n  <img\n    src={process.env.PUBLIC_URL + '/images/' + filename}\n    className=\"img-fluid mx-auto d-block\"\n    alt=\"screenshot\"\n    loading=\"lazy\"\n  />\n);\n\nexport default Image;\n"],"sourceRoot":""}