{"version":3,"sources":["pages/Lesson-03/index.js","pages/Lesson-03/code.js","components/Link/index.js","components/Image/index.js","components/Alert/index.js"],"names":["Lesson03","className","Image","filename","text","theme","hybrid","language","Alert","Link","link","type","class","href","target","rel","src","process","alt","loading","children","Provider","value","size"],"mappings":"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","file":"static/js/lesson-03.9906ad1f.chunk.js","sourcesContent":["import React from 'react';\nimport Alert from '../../components/Alert';\nimport Image from '../../components/Image';\nimport Link from '../../components/Link';\nimport { CopyBlock, hybrid } from 'react-code-blocks';\n\nimport * as code from './code';\n\nconst Lesson03 = () => (\n  <div className=\"container lesson-03\">\n    <div className=\"row\">\n      <div className=\"col\">\n        <h2>1. Компоненты-классы</h2>\n        <p>\n          Если необходимо добавить динамику, компоненты создаются как классы,\n          потому что компоненты-функции (до хуков) ограничены возможностью\n          создания разметки по полученным пропсам.\n        </p>\n        <Image filename=\"class-component.jpg\" />\n        <ul>\n          <li>\n            Обычный ES6 класс, поэтому применяются все правила: конструктор,\n            методы, контекст (this).\n          </li>\n          <li>\n            Обязательно расширяет базовый класс <code>React.Component</code>.\n          </li>\n          <li>\n            Действует как функция, которая получает <code>props</code>, но также\n            реализует приватное внутреннее состояние.\n          </li>\n          <li>\n            Необходимо объявить обязательный метод <code>render()</code>,\n            который вызывается по умолчанию и возвращает JSX-разметку.\n          </li>\n          <li>\n            Каждый раз при использовании компонента-класса, React будет\n            создавать экземпляр компонента (класса), поэтому доступ к пропсам\n            происходит через\n            <code>this.props</code>.\n          </li>\n          <li>\n            Можно определить кастомные методы класса и использовать их в любом\n            месте, в том числе внутри JSX, вызывать или передавать детям как\n            пропсы.\n          </li>\n          <li>\n            Когда изменяется состояние или пропcы компонента, происходит его\n            ре-рендер.\n          </li>\n        </ul>\n        <CopyBlock text={code.code1} theme={hybrid} language=\"jsx\" />\n      </div>\n    </div>\n\n    <div className=\"row\">\n      <div className=\"col\">\n        <h2>2. События</h2>\n        <p>\n          Для нативного события браузера в React создается объект-обертка\n          <code>SyntheticEvent Object</code> с идентичным интерфейсом. Это\n          необходимо чтобы предоставить кросс-бразуерность и оптимизировать\n          производительность.\n        </p>\n        <CopyBlock text={code.code2} theme={hybrid} language=\"jsx\" />\n        <ul>\n          <li>\n            Добавление обработчика событий с{' '}\n            <code>EventTarget.addEventListener()</code> почти не используется,\n            за редким исключением.\n          </li>\n          <li>\n            Пропсы событий не исключение и именуются с помощью camelCase.\n            Например\n            <code>onClick</code>, <code>onChange</code>, <code>onSubmit</code>,{' '}\n            <code>onMouseEnter</code>.\n          </li>\n          <li>\n            В проп события передается ссылка на callback-функцию, которая будет\n            вызвана при наступлении события.\n          </li>\n          <li>\n            Обработчики событий получают экземпляр{' '}\n            <code>SyntheticEvent Object</code>.\n          </li>\n        </ul>\n        <p>\n          В React реализовано глобальное делегирование событий. Слушатели не\n          добавляются к DOM-элементам напрямую. React использует один обработчик\n          событий на корне документа, который отвечает за прослушивание всех\n          событий и при необходимости вызывает соответствующий обработчик.\n        </p>\n        <Alert>\n          <p>\n            Именно поэтому объект <code>SyntheticEvent</code> всего один (на все\n            приложение) и доступен только в синхронном коде. Сразу после вызова\n            callback-функции он будет использован повторно и все свойства будут\n            аннулированы.\n          </p>\n        </Alert>\n\n        <h3>2.1. Счетчик</h3>\n        <p>\n          Создадим компонент-счетчик с возможностью увеличения и уменьшения\n          значения.\n        </p>\n        <CopyBlock text={code.code3} theme={hybrid} language=\"jsx\" />\n\n        <h3>2.2. Анонимные колбеки</h3>\n        <p>\n          Инлайн колбеки считаются антипаттерном. Каждый раз когда компонент\n          ре-рендерится, будет создана новая callback-функция. В многих случаях\n          это нормально. Но, если callback передается как проп нижележащим\n          компонентам в дереве, они будут отрендерены заново, так как придут\n          новые пропы ссылочного типа (функция).\n        </p>\n        <CopyBlock text={code.code4} theme={hybrid} language=\"jsx\" />\n\n        <h3>2.3. Кастомные методы</h3>\n        <p>\n          Чаще всего обработчики событий объявляются как методы класса, после\n          чего jsx-атрибуту передается ссылка на метод.\n        </p>\n        <CopyBlock text={code.code5} theme={hybrid} language=\"jsx\" />\n\n        <h3>2.4. Привязка контекста</h3>\n        <p>\n          Нужно всегда помнить о значении <code>this</code> в методах\n          использующихся как callback-функции. В JavaScript, контекст в методах\n          класса не привязывается по умолчанию. Если забыть привязать контекст,\n          и передать метод как callback-функцию обработчику события, во время\n          вызова функции, <code>this</code> будет неопределен (\n          <code>undefined</code>).\n        </p>\n\n        <h3>2.4.1. Привязка при передаче колбека</h3>\n        <p>\n          Избегайте привязки контекста в методе <code>render()</code>. Всякий\n          раз, когда компонент ре-рендерится,{' '}\n          <code>Function.prototype.bind()</code> возвращает новую функцию и\n          передает ее вниз по дереву компонентов, что приводит к повторному\n          рендеру дочерних компонентов. При достаточном количестве, это\n          оказывает существенное влияние на производительность.\n        </p>\n        <CopyBlock text={code.code6} theme={hybrid} language=\"jsx\" />\n\n        <h3>2.4.2. Привязка в конструкторе</h3>\n        <p>\n          Еще один способ привязать контекст - сделать это в конструкторе\n          класса. Если callback-функций много, можете себе представить,\n          насколько большой может получиться конструктор.\n        </p>\n        <ul>\n          <li>\n            Конструктор выполняется один раз, поэтому <code>bind</code>{' '}\n            вызовется один раз\n          </li>\n          <li>\n            Методы класса записываеются в свойство prototype\n            функции-конструктора\n          </li>\n        </ul>\n        <CopyBlock text={code.code7} theme={hybrid} language=\"jsx\" />\n\n        <h3>2.4.3. Публичные свойства класса</h3>\n        <p>\n          Несмотря на то, что это рекомендуемый способ привязки контекста,\n          синтаксис публичных полей класса еще не стандартизирован. Но они уже\n          настолько широко используются, что даже если будут синтаксические\n          изменения, транспайлер Babel все сделает за нас.\n        </p>\n        <p>\n          При объявлении публичных полей класса, они записываются не в свойство\n          <code>prototype</code> функции-конструктора, а в объект экземпляра.\n        </p>\n        <CopyBlock text={code.code8} theme={hybrid} language=\"jsx\" />\n\n        <h3>2.5. Дополнительные материалы</h3>\n        <ul>\n          <li>\n            <Link\n              link=\"https://ru.reactjs.org/docs/events.html\"\n              text=\"Документация SyntheticEvent\"\n            />\n          </li>\n          <li>\n            <Link\n              link=\"https://codeburst.io/pointer-events-with-react-the-why-how-what-617a5b51dbb2\"\n              text=\"Pointer events with React\"\n            />\n          </li>\n        </ul>\n      </div>\n    </div>\n\n    <div className=\"row\">\n      <div className=\"col\">\n        <h2>3. Внутреннее состояние компонента</h2>\n        <p>\n          Объект-состояния <code>state</code> это свойство класса которое не\n          должно изменяться разработчиком напрямую.\n        </p>\n        <ul>\n          <li>\n            Данные в <code>state</code> контролируют то, что отображается в\n            интерфейсе.\n          </li>\n          <li>\n            Данные, хранящиеся в состоянии, должны быть информацией, которая\n            будет обновляться методами компонента.\n          </li>\n          <li>\n            Не нужно дублировать данные из <code>props</code> в состоянии.\n          </li>\n          <li>\n            Каждый раз, когда изменяется состояние компонента (или пропсы),\n            вызывается метод <code>render()</code>.\n          </li>\n        </ul>\n        <p>\n          В состоянии хранят минимально необходимый набор данных, на основе\n          которых можно вычислить все необходимое для отрисовки интерфейса. Это\n          делается вызовом селекторов (функций которые составляют данные для\n          интерфейса на основе состояния) в методе <code>render()</code>. Так мы\n          получаем вычисляемые данные.\n        </p>\n        <Image filename=\"reactivity.jpg\" />\n        <ul>\n          <li>Интерфейс зависит от состояния компонента.</li>\n          <li>\n            Состояние может измениться как реакция на действия пользователя.\n          </li>\n          <li>\n            При изменении состояния, данные передаются вниз по дереву\n            компонентов.\n          </li>\n          <li>\n            Компоненты возвращают обновленную разметку и изменяется интерфейс.\n          </li>\n        </ul>\n        <p>\n          Состояние принадлежит компоненту и изменяется только его методами.\n          Изменение состояния компонента никогда не повлияет на его родителя,\n          соседей или любой другой компонент в приложении - только на его\n          дочерние элементы. При такой модели, данные в приложении передаются\n          только одним, жестко ограниченным образом. Это называется\n          однонаправленный поток данных.\n        </p>\n        <Image filename=\"data-flow.data-flow.jpg\" />\n        <p>\n          Состояние объявляется в конструкторе, так как это первое, что\n          происходит, когда создается экземпляр класса.\n        </p>\n        <CopyBlock text={code.code9} theme={hybrid} language=\"jsx\" />\n\n        <h3>3.1. Начальное состояние от props</h3>\n        <p>\n          Иногда начальное состояние зависит от переданных пропсов, например\n          начальное значение нашего счетчика. В этом случае, необходимо явно\n          объявить параметр\n          <code>props</code> в конструкторе и передать его в вызов{' '}\n          <code>super(props)</code>. Тогда в конструкторе будет доступно{' '}\n          <code>this.props</code>.\n        </p>\n        <CopyBlock text={code.code10} theme={hybrid} language=\"jsx\" />\n\n        <p>\n          Так как под капотом используется Babel, можно пропустить утомительное\n          объявление конструктора и указать состояние как публичное свойство\n          класса, все остальное транспайлер сделает за нас.\n        </p>\n        <CopyBlock text={code.code11} theme={hybrid} language=\"jsx\" />\n\n        <h3>3.2. Изменение состояния компонента</h3>\n        <p>\n          Для обновления состояния используется встроенный метод{' '}\n          <code>setState()</code>.\n        </p>\n        <CopyBlock text={code.code12} theme={hybrid} language=\"jsx\" />\n\n        <ul>\n          <li>\n            Первым, обязательным аргументом, передается объект с полями\n            указывающими какую часть состояния необходимо изменить.\n          </li>\n          <li>\n            Вторым, необязательным аргументом, можно передать callback-функцию\n            которая выполнится после изменения состояния.\n          </li>\n        </ul>\n        <Alert type=\"error\">\n          <p>\n            Нельзя изменять состояние напрямую по ссылке. Будьте очень\n            внимательны, особенно при работе со ссылочными типами (массив,\n            объект).\n          </p>\n        </Alert>\n        <CopyBlock text={code.code13} theme={hybrid} language=\"jsx\" />\n\n        <p>\n          Этот подход используется когда новое состояние не рассчитывается на\n          основе предыдущего. То есть когда в состояние записывается что-то\n          новое, перезаписывая уже существующее. Сделаем компонент с\n          переключателем, методы которого будут перезаписывать значение{' '}\n          <code>isOpen</code> в состоянии.\n        </p>\n        <CopyBlock text={code.code14} theme={hybrid} language=\"jsx\" />\n\n        <h3>3.3. Как обновляется состояние</h3>\n        <p>\n          При вызове <code>setState()</code> не нужно передавать все свойства\n          хранящиеся в состоянии. Достаточно указать только ту часть (срез)\n          состояния, которую мы хотим изменить в данной операции. React затем\n          берет текущее состояние и объект, который был передан в{' '}\n          <code>setState()</code>, объединяя их следующим образом.\n        </p>\n        <CopyBlock text={code.code15} theme={hybrid} language=\"jsx\" />\n\n        <h3>3.4. Асинхронность обновления состояния</h3>\n        <p>\n          Метод <code>setState()</code> регистрирует асинхронную операцию\n          обновления состояния, которая ставится в очередь обновлений. React\n          изменяет состояние не для каждого вызова <code>setState()</code>, а\n          может объединять несколько вызовов в одно обновление для повышения\n          производительности. Из-за этого доступ к <code>this.state</code>, в\n          синхронном коде, после вызова этого метода вернет значение до\n          обновления.\n        </p>\n        <p>\n          Представьте, что при изменении состояния, вы полагаетесь на текущее\n          значение состояния при вычислении следующего. Используем цикл{' '}\n          <code>for</code> для создания (регистрации) нескольких обновлений.\n        </p>\n        <CopyBlock text={code.code16} theme={hybrid} language=\"jsx\" />\n\n        <p>\n          Значение свойства <code>this.state.value</code> запоминается во время\n          создания объекта передаваемого в <code>setState()</code>, а не во\n          время обновления состояния. То есть, если в момент создания объекта,{' '}\n          <code>this.state.value</code> содержало <code>0</code>, в функцию\n          <code>setState()</code> передается объект{' '}\n          <code>{'{value: 0 + 1}'}</code>.\n        </p>\n        <p>\n          В результате выполнения цикла получаем очередь из 3-х объектов\n          <code>\n            {'{value: 0 + 1}'}, {'{value: 0 + 1}'}, {'{value: 0 + 1}'}\n          </code>{' '}\n          и оригинальное состояние на момент обновления{' '}\n          <code>{'{value: 0 + 1}'}</code>. После всех обновлений получаем\n          состояние\n          <code>{'{value: 0 + 1}'}</code>.\n        </p>\n        <p>\n          Поэтому нельзя полагаться на текущее состояние при вычислении\n          следующего, зависящего от предыдущего на момент обновления. Это может\n          привести к ошибкам. Поэтому существует второй способ обновить\n          состояние.\n        </p>\n\n        <h3>3.5. setState с функцией</h3>\n        <p>\n          Этот подход используется, когда новое значение вычисляется на основе\n          предыдущего состояния. Метод <code>setState()</code>, первым\n          аргументом, может принимать не объект, а функцию, которая должна\n          возвращать объект которым мы хотим обновить состояние.\n        </p>\n        <CopyBlock text={code.code17} theme={hybrid} language=\"jsx\" />\n\n        <p>\n          Актуальное состояние и пропы, на момент асинхронного исполнения\n          функции переданной в <code>setState()</code>, будут переданы в нее\n          аргументами <code>state</code> и <code>props</code>. Таким образом,\n          можно быть уверенными в корректном значении предыдущего состояния при\n          создании следующего.\n        </p>\n        <CopyBlock text={code.code18} theme={hybrid} language=\"jsx\" />\n\n        <p>\n          Каждый раз, во время вызова функции переданной в{' '}\n          <code>setState()</code>, в параметр\n          <code>prevState</code> будет передана ссылка на актуальное состояние в\n          момент обновления. Получим объекты обновлений{' '}\n          <code>{'{value: 0 + 1}'}</code>, <code>{'{value: 1 + 1}'}</code>,{' '}\n          <code>{'{value: 2 + 1}'}</code>, и, в результате,{' '}\n          <code>this.state.value</code> будет содержать <code>3</code>.\n        </p>\n        <p>\n          Теперь можем заменить функционал открыть/закрыть в компоненте{' '}\n          <code>\n            <span class=\"token tag\">\n              <span class=\"token tag\">\n                <span class=\"token punctuation\">&lt;</span>Toggle\n              </span>\n              <span class=\"token punctuation\">&gt;</span>\n            </span>\n          </code>\n          .\n        </p>\n        <CopyBlock text={code.code19} theme={hybrid} language=\"jsx\" />\n\n        <p>А счетчик будет выглядеть так.</p>\n        <CopyBlock text={code.code20} theme={hybrid} language=\"jsx\" />\n\n        <h3>3.6. Подъем состояния (state hoisting)</h3>\n        <p>\n          Так как React использует однонаправленный поток данных сверху вниз,\n          для того, чтобы изменить состояние родителя при событии в ребенке,\n          используется следующий паттерн с callback-функцией.\n        </p>\n        <Image filename=\"state-hoisting.gif\" />\n        <ul>\n          <li>В родителе есть состояние и метод который его изменяет.</li>\n          <li>\n            Ребенку, в виде пропа, пробрасывается метод родителя изменяющий\n            состояние родителя.\n          </li>\n          <li>В ребенке происходит вызов переданного ему метода.</li>\n          <li>При вызове этого метода изменяется состояние родителя.</li>\n          <li>Происходит ре-рендер поддерева компонентов родителя.</li>\n        </ul>\n        <p>Рассмотрим простой, но наглядный пример.</p>\n        <CopyBlock text={code.code21} theme={hybrid} language=\"jsx\" />\n\n        <p>\n          При клике кнопки, состояние <code>App</code> обновляется с помощью\n          callback-функции, контекст которой привязан к <code>App</code>. Этот\n          паттерн устанавливает четкую границу между \"умными\" и \"глупыми\"\n          компонентами.\n        </p>\n        <p>Паттерн подъема состояния может иметь любую вложенность.</p>\n        <Image filename=\"deep-state-hoisting.gif\" />\n      </div>\n    </div>\n\n    <div className=\"row\">\n      <div className=\"col\">\n        <h2>4. Типы внутренних данных компонента</h2>\n        <ul>\n          <li>\n            <code>static data</code> - статические свойства и методы к которым\n            необходимо получать доступ без экземпляра.\n          </li>\n          <li>\n            <code>this.state.data</code> - динамические данные изменяющиеся\n            методами компонента, состояние.\n          </li>\n          <li>\n            <code>this.data</code> - данные которые будут разные для каждого\n            экземпляра.\n          </li>\n          <li>\n            <code>const DATA</code> - константы, данные которые не изменяются и\n            одинаковы для всех экземпляров.\n          </li>\n        </ul>\n      </div>\n    </div>\n  </div>\n);\n\nexport default Lesson03;\n","export const code1 = `// Отделяйте именованные импорты, это повышает читаемость кода\nimport React, { Component } from 'react';\n\nclass MyClassComponent extends Component {\n  static defaultProps = {};\n\n  static propTypes = {};\n\n  render() {\n    return <div>Class Component</div>;\n  }\n}`;\n\nexport const code2 = `<button onClick={event => console.log(event)}>Click me!</button>`;\n\nexport const code3 = `import React, { Component } from 'react';\nimport ReactDOM from 'react-dom';\n\nclass Counter extends Component {\n  static defaultProps = {\n    step: 1,\n  };\n\n  render() {\n    const { step } = this.props;\n\n    return (\n      <div>\n        <span>0</span>\n        <button type=\"button\">Increment by {step}</button>\n        <button type=\"button\">Decrement by {step}</button>\n      </div>\n    );\n  }\n}\n\nReactDOM.render(<Counter step={5} />, document.getElementById('root'));`;\n\nexport const code4 = `class Counter extends Component {\n  /* ... */\n\n  render() {\n    const { step } = this.props;\n\n    return (\n      <div>\n        <span>0</span>\n        <button\n          type=\"button\"\n          onClick={evt => {\n            console.log('Increment button was clicked!', evt); // работает\n            console.log('this.props: ', this.props); // работает\n          }}\n        >\n          > Increment by {step}\n        </button>\n        <button\n          type=\"button\"\n          onClick={evt => {\n            console.log('Decrement button was clicked!', evt); // работает\n            console.log('this.props: ', this.props); // работает\n          }}\n        >\n          Decrement by {step}\n        </button>\n      </div>\n    );\n  }\n}`;\n\nexport const code5 = `class Counter extends Component {\n  /* ... */\n\n  handleIncrement(evt) {\n    console.log('Increment button was clicked!', evt); // работает\n    console.log('this.props: ', this.props); // Error: cannot read props of undefined\n  }\n\n  handleDecrement(evt) {\n    console.log('Decrement button was clicked!', evt); // работает\n    console.log('this.props: ', this.props); // Error: cannot read props of undefined\n  }\n\n  render() {\n    const { step } = this.props;\n\n    return (\n      <div>\n        <span>0</span>\n        <button type=\"button\" onClick={this.handleIncrement}>\n          Increment by {step}\n        </button>\n        <button type=\"button\" onClick={this.handleDecrement}>\n          Decrement by {step}\n        </button>\n      </div>\n    );\n  }\n}`;\n\nexport const code6 = `// ❌ Плохо\nclass Counter extends Component {\n  /* ... */\n\n  handleIncrement(evt) {\n    // ...\n  }\n\n  handleDecrement(evt) {\n    // ...\n  }\n\n  render() {\n    const { step } = this.props;\n\n    return (\n      <div>\n        <span>0</span>\n        <button type=\"button\" onClick={this.handleIncrement.bind(this)}>\n          Increment by {step}\n        </button>\n        <button type=\"button\" onClick={this.handleDecrement.bind(this)}>\n          Decrement by {step}\n        </button>\n      </div>\n    );\n  }\n}`;\n\nexport const code7 = `// ✅ Хорошо\nclass Counter extends Component {\n  /* ... */\n\n  constructor() {\n    super();\n\n    this.handleIncrement = this.handleIncrement.bind(this);\n    this.handleDecrement = this.handleDecrement.bind(this);\n  }\n\n  handleIncrement(evt) {\n    // ...\n  }\n\n  handleDecrement(evt) {\n    // ...\n  }\n\n  render() {\n    const { step } = this.props;\n\n    return (\n      <div>\n        <span>0</span>\n        <button type=\"button\" onClick={this.handleIncrement}>\n          Increment by {step}\n        </button>\n        <button type=\"button\" onClick={this.handleDecrement}>\n          Decrement by {step}\n        </button>\n      </div>\n    );\n  }\n}`;\n\nexport const code8 = `// ✅ Хорошо\nclass Counter extends Component {\n  /* ... */\n\n  handleIncrement = evt => {\n    console.log('Increment button was clicked!', evt); // работает\n    console.log('this.props: ', this.props); // работает\n  };\n\n  handleDecrement = evt => {\n    console.log('Decrement button was clicked!', evt); // работает\n    console.log('this.props: ', this.props); // работает\n  };\n\n  render() {\n    const { step } = this.props;\n\n    return (\n      <div>\n        <span>0</span>\n        <button type=\"button\" onClick={this.handleIncrement}>\n          Increment by {step}\n        </button>\n        <button type=\"button\" onClick={this.handleDecrement}>\n          Decrement by {step}\n        </button>\n      </div>\n    );\n  }\n}`;\n\nexport const code9 = `class Counter extends Component {\n  constructor() {\n    super();\n\n    this.state = {\n      value: 0,\n    };\n  }\n\n  /* ... */\n\n  render() {\n    return (\n      <div>\n        <span>{this.state.value}</span>\n        {/* ... */}\n      </div>\n    );\n  }\n}`;\n\nexport const code10 = `class Counter extends Component {\n  static defaultProps = {\n    step: 1,\n    initialValue: 0,\n  };\n\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      value: this.props.initialValue,\n    };\n  }\n\n  /* ... */\n}\n\nReactDOM.render(<Counter initialValue={10} />, document.getElementById('root'));`;\n\nexport const code11 = `class Counter extends Component {\n  static defaultProps = {\n    step: 1,\n    initialValue: 0,\n  };\n\n  state = {\n    value: this.props.initialValue,\n  };\n\n  /* ... */\n}`;\n\nexport const code12 = `setState(updater, callback)`;\n\nexport const code13 = `state = { fullName: 'Poly' };\n\n// ❌ Плохо\nthis.state.fullName = 'Mango';\n\n// ✅ Хорошо\nthis.setState({\n  fullName: 'Mango',\n});`;\n\nexport const code14 = `class Toggle extends Component {\n  state = { isOpen: false };\n\n  show = () => this.setState({ isOpen: true });\n\n  hide = () => this.setState({ isOpen: false });\n\n  render() {\n    const { isOpen } = this.state;\n    const { children } = this.props;\n\n    return (\n      <>\n        <button onClick={this.show}>Show</button>\n        <button onClick={this.hide}>Hide</button>\n        {isOpen && children}\n      </>\n    );\n  }\n}`;\n\nexport const code15 = `// состояние перед объединением\nconst currentState = { a: 2, b: 3, c: 7, d: 9 };\n\n// объект переданный в setState\nconst updateSlice = { b: 5, d: 4 };\n\n// новое значение this.state после объединения\nconst nextState = { ...currentState, ...updateSlice }; // {a: 2, b: 5, c: 7, d: 4}`;\n\nexport const code16 = `// Предположим что есть такое состояние\nstate = { value: 0 };\n\n// Запустим цикл и создадим 3 операции обновления\nfor (let i = 0; i < 3; i += 1) {\n  /*\n   * Если посмотреть состояние, на всех итерациях будет 0\n   * Потому что это синхронный код и обновление состояния еще не произошло\n   */\n  console.log(this.state.value);\n\n  this.setState({ value: this.state.value + 1 });\n}`;\n\nexport const code17 = `setState((state, props) => {\n  return {}\n}, callback)`;\n\nexport const code18 = `// Предположим что есть такое состояние\nstate = { value: 0 };\n\n// Запустим цикл и создадим 3 операции обновления\nfor (let i = 0; i < 3; i += 1) {\n  /*\n   * Если посмотреть состояние, на всех итерациях будет 0\n   * Потому что это синхронный код и обновление состояния еще не произошло\n   */\n  console.log(this.state.value); // 0\n\n  this.setState(prevState => {\n    /*\n     * Если посмотреть состояние переданное callback-функции во время ее вызова,\n     * получим актуальное состояния на момент обновления.\n     */\n    console.log(prevState.value); // будет разный на каждой итерации\n\n    return { value: prevState.value + 1 };\n  });\n}`;\n\nexport const code19 = `class Toggle extends Component {\n  state = { isOpen: false };\n\n  toggle = () => {\n    this.setState(state => ({ isOpen: !state.isOpen }));\n  };\n\n  render() {\n    const { isOpen } = this.state;\n    const { children } = this.props;\n\n    return (\n      <div>\n        <button onClick={this.toggle}>{isOpen ? 'Hide' : 'Show'}</button>\n        {isOpen && children}\n      </div>\n    );\n  }\n}`;\n\nexport const code20 = `class Counter extends Component {\n  /* ... */\n\n  handleIncrement = () => {\n    this.setState((state, props) => ({\n      value: state.value + props.step,\n    }));\n  };\n\n  handleDecrement = () => {\n    this.setState((state, props) => ({\n      value: state.value - props.step,\n    }));\n  };\n\n  /* ... */\n}`;\n\nexport const code21 = `/*\n* Button получает функцию changeMessage (имя пропа),\n* которая вызывается при событии onClick\n*/\nconst Button = ({ changeMessage, label }) => (\n <button type=\"button\" onClick={changeMessage}>\n   {label}\n </button>\n);\n\nclass App extends Component {\n state = {\n   message: new Date().toLocaleTimeString(),\n };\n\n // Метод который будем передавать в Button для вызова при клике\n updateMessage = evt => {\n   console.log(evt); // Доступен объект события\n\n   this.setState({\n     message: new Date().toLocaleTimeString(),\n   });\n };\n\n render() {\n   return (\n     <>\n       <span>{this.state.message}</span>\n       <Button label=\"Change message\" changeMessage={this.updateMessage} />\n     </>\n   );\n }\n}`;\n","import React from 'react';\n\nconst Link = ({ link, text }) => (\n  <a href={link} target=\"_blank\" rel=\"noopener noreferrer\">\n    {text}\n  </a>\n);\n\nexport default Link;\n","import React from 'react';\n\nconst Image = ({ filename }) => (\n  <img\n    src={process.env.PUBLIC_URL + '/images/' + filename}\n    className=\"img-fluid mx-auto d-block\"\n    alt=\"screenshot\"\n    loading=\"lazy\"\n  />\n);\n\nexport default Image;\n","import React from 'react';\nimport { IoIosInformationCircleOutline } from 'react-icons/io';\nimport { IconContext } from 'react-icons';\n\nconst Alert = ({ children }) => (\n  <IconContext.Provider value={{ size: '2em' }}>\n    <div className=\"alert alert-primary\">\n      <div className=\"icon\">\n        <IoIosInformationCircleOutline />\n      </div>\n      <div className=\"text\">{children}</div>\n    </div>\n  </IconContext.Provider>\n);\n\nexport default Alert;\n"],"sourceRoot":""}